package main

import (
	"fmt"
	"image"
	_ "image/png"
	"math"
	"os"

	"github.com/fang2hou/easyga"
)

type imageData struct {
	height, width int
	brightness    [][]int
}

type imageNoise struct {
	ga        easyga.GeneticAlgorithm
	original  imageData
	corrupted imageData
}

func main() {
	var findNoise imageNoise

	// Original
	findNoise.original = readFromFile("lena.png")
	// Corrupted
	findNoise.corrupted = readFromFile("lena.png_noisy_NA_60.0000_NFRow_0.0100_NFCol_0.0100.png")

	// Confirm the size of two pictures is same.
	if findNoise.corrupted.width != findNoise.original.width ||
		findNoise.corrupted.height != findNoise.original.width {
		fmt.Println("The size of two pictures is not same!")
		return
	}

	findNoise.init()

}

func (in *imageNoise) init() {
	// TODO: configuration

	// Every gene:
	// Index  0- 7 => NoiseAmp
	// Index  8-15 => NoiseFreqRow
	// Index 16-23 => NoiseFreqCol
	parameters := easyga.GeneticAlgorithmParameters{
		CrossoverProbability: .8,
		MutationProbability:  .2,
		PopulationSize:       20,
		GenotypeNumber:       2,
		ChromosomeLength:     24,
		IterationsLimit:      1000,
		RandomSeed:           42,
	}

	custom := easyga.GeneticAlgorithmFunctions{
		FitnessFunction: func(c *easyga.Chromosome) {
			// Error function assumed (Example)
			// NoiseAmp     (0, 30.0]
			// NoiseFreqRow (0, 0.01]
			// NoiseFreqCol (0, 0.01]
			// N(row, col) = NoiseAmp × sin([2π × NoiseFreqRow × row] + [2π × NoiseFreqCol × col])

			// The picture given is generated by 60.0, 0.01, 0.01
			// But for the gap between math functions of different programming language,
			// 60.10909579768 is accurate adequately in confirmation.

			NoiseAmp := geneToPercent(c.Gene[:8]) * 30.
			NoiseFreqRow := geneToPercent(c.Gene[8:16]) * .01
			NoiseFreqCol := geneToPercent(c.Gene[16:24]) * .01

			c.Fitness = 0
			for row := 0; row < in.original.height; row++ {
				for col := 0; col < in.original.width; col++ {
					newBrightness := float64(in.original.brightness[row][col]) +
						NoiseAmp*math.Sin(2.0*math.Pi*(NoiseFreqRow*float64(row+1)+NoiseFreqCol*float64(col+1)))

					// Fix the new brightness over 255 or below 0.
					if newBrightness < 0 {
						newBrightness = 0
					} else if newBrightness > 255 {
						newBrightness = 255
					}

					// (Original + NoiseGA) - Corrupted
					c.Fitness += newBrightness - float64(in.corrupted.brightness[row][col])
				}
			}

			return
		},
		CheckStopFunction: func(ga *easyga.GeneticAlgorithm) bool {
			return false
		},
	}

	if err := in.ga.Init(parameters, custom); err != nil {
		fmt.Println(err)
		return
	}
}

func readFromFile(fileName string) (inputImage imageData) {
	// Open image file.
	file, err := os.Open(fileName)
	defer file.Close()

	if err != nil {
		fmt.Println(err)
		return
	}

	// Decode
	img, _, err := image.Decode(file)

	if err != nil {
		fmt.Println(err)
		return
	}

	// Get bounds
	rect := img.Bounds()
	inputImage.width = rect.Max.X
	inputImage.height = rect.Max.Y

	// Color reduction
	for i := 0; i < rect.Max.Y; i++ {
		tempLine := make([]int, 0)
		for j := 0; j < rect.Max.X; j++ {
			// For greyscale image, red = green = blue = brightness.
			red, _, _, _ := img.At(j, i).RGBA()
			// Convert [0, 65536) -> [0, 256)
			tempLine = append(tempLine, int(red>>8))
		}
		inputImage.brightness = append(inputImage.brightness, tempLine)
	}

	return
}

func geneToPercent(gene []byte) (percent float64) {
	length := len(gene)
	max := math.Pow(2., float64(length)) - 1

	var number float64
	for i := length - 1; i >= 0; i-- {
		number += float64(gene[i]) * math.Pow(2.0, float64(i))
	}

	percent = number / max

	return
}
