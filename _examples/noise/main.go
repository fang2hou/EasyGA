package main

import (
	"fmt"
	"image"
	_ "image/png"
	"math"
	"os"

	"github.com/fang2hou/easyga"
)

type imageData struct {
	height, width int
	brightness    [][]int
}

type imageNoise struct {
	ga        easyga.GeneticAlgorithm
	original  imageData
	corrupted imageData
}

func main() {
	var findNoise imageNoise

	// Original
	findNoise.original = readFromFile("lena.png")
	// Corrupted
	findNoise.corrupted = readFromFile("lena.png_noisy_NA_60.0000_NFRow_0.0100_NFCol_0.0100.png")

	// Confirm the size of two pictures is same.
	if findNoise.corrupted.width != findNoise.original.width ||
		findNoise.corrupted.height != findNoise.original.width {
		fmt.Println("The size of two pictures is not same!")
		return
	}

	// The picture given is generated by 60.0, 0.01, 0.01
	// But for the gap between math functions of different programming language,
	// 60.10909579768 is accurate adequately in confirmation.
	fmt.Println(findNoise.totalError(60.10909579768, 0.01, 0.01))
}

func (in *imageNoise) init() {
	// TODO: configuration
	parameters := easyga.GeneticAlgorithmParameters{
		CrossoverProbability: .8,
		MutationProbability:  .2,
		PopulationSize:       20,
		GenotypeNumber:       2,
		ChromosomeLength:     10,
		IterationsLimit:      1000,
		RandomSeed:           42,
	}

	custom := easyga.GeneticAlgorithmFunctions{
		ChromosomeInitFunction: func(c *easyga.Chromosome) {
			return
		},
		FitnessFunction: func(c *easyga.Chromosome) {
			return
		},
		CheckStopFunction: func(ga *easyga.GeneticAlgorithm) bool {
			return false
		},
	}

	if err := in.ga.Init(parameters, custom); err != nil {
		fmt.Println(err)
		return
	}
}

func (in *imageNoise) totalError(NoiseAmp float64, NoiseFreqRow float64, NoiseFreqCol float64) (fitness float64) {
	var noise float64

	// Error function assumed (Example)
	// NoiseAmp     (0, 30.0]
	// NoiseFreqRow (0, 0.01]
	// NoiseFreqCol (0, 0.01]
	// N(row, col) = NoiseAmp × sin([2π × NoiseFreqRow × row] + [2π × NoiseFreqCol × col])
	for row := 0; row < in.original.height; row++ {
		for col := 0; col < in.original.width; col++ {
			noise = NoiseAmp * math.Sin(2.0*math.Pi*(NoiseFreqRow*float64(row+1)+NoiseFreqCol*float64(col+1)))
			newBrightness := float64(in.original.brightness[row][col]) + noise

			// Fix the new brightness over 255 or below 0.
			if newBrightness < 0 {
				newBrightness = 0
			} else if newBrightness > 255 {
				newBrightness = 255
			}

			// (Original + NoiseGA) - Corrupted
			fitness += newBrightness - float64(in.corrupted.brightness[row][col])
		}
	}

	return
}

func readFromFile(fileName string) (inputImage imageData) {
	// Open image file.
	file, err := os.Open(fileName)
	defer file.Close()

	if err != nil {
		fmt.Println(err)
		return
	}

	// Decode
	img, _, err := image.Decode(file)

	if err != nil {
		fmt.Println(err)
		return
	}

	// Get bounds
	rect := img.Bounds()
	inputImage.width = rect.Max.X
	inputImage.height = rect.Max.Y

	// Color reduction
	for i := 0; i < rect.Max.Y; i++ {
		tempLine := make([]int, 0)
		for j := 0; j < rect.Max.X; j++ {
			// For greyscale image, red = green = blue = brightness.
			red, _, _, _ := img.At(j, i).RGBA()
			// Convert [0, 65536) -> [0, 256)
			tempLine = append(tempLine, int(red>>8))
		}
		inputImage.brightness = append(inputImage.brightness, tempLine)
	}

	return
}
